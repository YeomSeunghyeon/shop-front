{"ast":null,"code":"/*\n  @license\n\tRollup.js v3.29.1\n\tSun, 10 Sep 2023 05:55:18 GMT - commit 40da6f85525c2ce48d9fd8d5c3579c41d8ef47a8\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { resolve } from 'node:path';\nimport process$1 from 'node:process';\nimport { picomatch as picomatch$2, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './node-entry.js';\nimport { platform } from 'node:os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$2 from 'path';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport 'node:perf_hooks';\nimport 'node:crypto';\nimport 'node:fs/promises';\nimport 'tty';\nvar chokidar = {};\nconst fs$3 = require$$0$1;\nconst {\n  Readable\n} = require$$1;\nconst sysPath$3 = require$$0$2;\nconst {\n  promisify: promisify$3\n} = require$$2;\nconst picomatch$1 = picomatch$2;\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = {\n      ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat$2 : stat$3;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = 'Dirent' in fs$3 && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = {\n        path: sysPath$3.relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp$1 = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n  options.root = root;\n  return new ReaddirpStream(options);\n};\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\nvar readdirp_1 = readdirp$1;\nvar anymatch$2 = {\n  exports: {}\n};\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function (path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n  if (path === '\\\\' || path === '/') return '/';\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\nvar anymatch_1 = anymatch$2.exports;\nObject.defineProperty(anymatch_1, \"__esModule\", {\n  value: true\n});\nconst picomatch = picomatch$2;\nconst normalizePath$1 = normalizePath$2;\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\nconst arrify$1 = item => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n  return string => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n  const path = normalizePath$1(_path, false);\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG$1).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG$1).map(matcher => createPattern(matcher, opts));\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\nvar anymatchExports = anymatch$2.exports;\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n  var match;\n  while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = isExtglob$1;\nvar chars = {\n  '{': '}',\n  '(': ')',\n  '[': ']'\n};\nvar strictCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\nvar relaxedCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n  if (isExtglob(str)) {\n    return true;\n  }\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n  return check(str);\n};\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({\n    flipBackslashes: true\n  }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\nvar utils$3 = {};\n(function (exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n    return false;\n  };\n\n  /**\n   * Find a node of the given type\n   */\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n  /**\n   * Find a node of the given type\n   */\n\n  exports.exceedsLimit = (min, max, step = 1, limit) => {\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n  exports.escapeNode = (block, n = 0, type) => {\n    let node = block.nodes[n];\n    if (!node) return;\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n    return false;\n  };\n\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n    return node.open === true || node.close === true;\n  };\n\n  /**\n   * Reduce an array of text nodes.\n   */\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n\n  /**\n   * Flatten an array\n   */\n\n  exports.flatten = (...args) => {\n    const result = [];\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n      }\n      return result;\n    };\n    flat(args);\n    return result;\n  };\n})(utils$3);\nconst utils$2 = utils$3;\nvar stringify$4 = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n    if (node.value) {\n      return node.value;\n    }\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber$2 = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isNumber$1 = isNumber$2;\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n  stop = countZeros(max + 1, zeros) - 1;\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      count++;\n    }\n  }\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n  return tokens;\n}\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n  for (let ele of arr) {\n    let {\n      string\n    } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange$1.cache = {};\ntoRegexRange$1.clearCache = () => toRegexRange$1.cache = {};\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange$1;\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\nconst isNumber = num => Number.isInteger(+num);\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? '-' + input : input;\n};\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n  return result;\n};\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n  return range;\n};\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n  let range = [];\n  let index = 0;\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n  return range;\n};\nconst fill$2 = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, {\n      transform: step\n    });\n  }\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n  let opts = {\n    ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\nvar fillRange = fill$2;\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\nconst compile$1 = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n    if (node.value) {\n      return node.value;\n    }\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, {\n        ...options,\n        wrap: false,\n        toRegex: true\n      });\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n  return walk(ast);\n};\nvar compile_1 = compile$1;\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n  return utils.flatten(result);\n};\nconst expand$1 = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n    return queue;\n  };\n  return utils.flatten(walk(ast));\n};\nvar expand_1 = expand$1;\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n  /* 0 */\n  CHAR_9: '9',\n  /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n  /* A */\n  CHAR_LOWERCASE_A: 'a',\n  /* a */\n  CHAR_UPPERCASE_Z: 'Z',\n  /* Z */\n  CHAR_LOWERCASE_Z: 'z',\n  /* z */\n\n  CHAR_LEFT_PARENTHESES: '(',\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: ')',\n  /* ) */\n\n  CHAR_ASTERISK: '*',\n  /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n  /* & */\n  CHAR_AT: '@',\n  /* @ */\n  CHAR_BACKSLASH: '\\\\',\n  /* \\ */\n  CHAR_BACKTICK: '`',\n  /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r',\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n  /* ^ */\n  CHAR_COLON: ':',\n  /* : */\n  CHAR_COMMA: ',',\n  /* , */\n  CHAR_DOLLAR: '$',\n  /* . */\n  CHAR_DOT: '.',\n  /* . */\n  CHAR_DOUBLE_QUOTE: '\"',\n  /* \" */\n  CHAR_EQUAL: '=',\n  /* = */\n  CHAR_EXCLAMATION_MARK: '!',\n  /* ! */\n  CHAR_FORM_FEED: '\\f',\n  /* \\f */\n  CHAR_FORWARD_SLASH: '/',\n  /* / */\n  CHAR_HASH: '#',\n  /* # */\n  CHAR_HYPHEN_MINUS: '-',\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: '{',\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n  /* [ */\n  CHAR_LINE_FEED: '\\n',\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n  /* \\u00A0 */\n  CHAR_PERCENT: '%',\n  /* % */\n  CHAR_PLUS: '+',\n  /* + */\n  CHAR_QUESTION_MARK: '?',\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}',\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n  /* ] */\n  CHAR_SEMICOLON: ';',\n  /* ; */\n  CHAR_SINGLE_QUOTE: '\\'',\n  /* ' */\n  CHAR_SPACE: ' ',\n  /*   */\n  CHAR_TAB: '\\t',\n  /* \\t */\n  CHAR_UNDERSCORE: '_',\n  /* _ */\n  CHAR_VERTICAL_LINE: '|',\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\nconst stringify$1 = stringify$4;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n  /* \\ */\n  CHAR_BACKTICK,\n  /* ` */\n  CHAR_COMMA,\n  /* , */\n  CHAR_DOT,\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n  push({\n    type: 'bos'\n  });\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n      while (index < length && (next = advance())) {\n        value += next;\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n        value += next;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify$1(block)\n        }];\n      }\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({\n      type: 'text',\n      value\n    });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\nvar parse_1 = parse$1;\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = (input, options = {}) => {\n  let output = [];\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces$1.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n  return options.expand !== true ? braces$1.compile(input, options) : braces$1.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces$1;\nconst require$$0 = [\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"];\nvar binaryExtensions$1 = require$$0;\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1;\nconst extensions = new Set(binaryExtensions);\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\nvar constants = {};\n(function (exports) {\n  const {\n    sep\n  } = require$$0$2;\n  const {\n    platform\n  } = process;\n  const os = require$$2$1;\n  exports.EV_ALL = 'all';\n  exports.EV_READY = 'ready';\n  exports.EV_ADD = 'add';\n  exports.EV_CHANGE = 'change';\n  exports.EV_ADD_DIR = 'addDir';\n  exports.EV_UNLINK = 'unlink';\n  exports.EV_UNLINK_DIR = 'unlinkDir';\n  exports.EV_RAW = 'raw';\n  exports.EV_ERROR = 'error';\n  exports.STR_DATA = 'data';\n  exports.STR_END = 'end';\n  exports.STR_CLOSE = 'close';\n  exports.FSEVENT_CREATED = 'created';\n  exports.FSEVENT_MODIFIED = 'modified';\n  exports.FSEVENT_DELETED = 'deleted';\n  exports.FSEVENT_MOVED = 'moved';\n  exports.FSEVENT_CLONED = 'cloned';\n  exports.FSEVENT_UNKNOWN = 'unknown';\n  exports.FSEVENT_TYPE_FILE = 'file';\n  exports.FSEVENT_TYPE_DIRECTORY = 'directory';\n  exports.FSEVENT_TYPE_SYMLINK = 'symlink';\n  exports.KEY_LISTENERS = 'listeners';\n  exports.KEY_ERR = 'errHandlers';\n  exports.KEY_RAW = 'rawEmitters';\n  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n  exports.DOT_SLASH = `.${sep}`;\n  exports.BACK_SLASH_RE = /\\\\/g;\n  exports.DOUBLE_SLASH_RE = /\\/\\//;\n  exports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n  exports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  exports.REPLACER_RE = /^\\.[/\\\\]/;\n  exports.SLASH = '/';\n  exports.SLASH_SLASH = '//';\n  exports.BRACE_START = '{';\n  exports.BANG = '!';\n  exports.ONE_DOT = '.';\n  exports.TWO_DOTS = '..';\n  exports.STAR = '*';\n  exports.GLOBSTAR = '**';\n  exports.ROOT_GLOBSTAR = '/**/*';\n  exports.SLASH_GLOBSTAR = '/**';\n  exports.DIR_SUFFIX = 'Dir';\n  exports.ANYMATCH_OPTS = {\n    dot: true\n  };\n  exports.STRING_TYPE = 'string';\n  exports.FUNCTION_TYPE = 'function';\n  exports.EMPTY_STR = '';\n  exports.EMPTY_FN = () => {};\n  exports.IDENTITY_FN = val => val;\n  exports.isWindows = platform === 'win32';\n  exports.isMacos = platform === 'darwin';\n  exports.isLinux = platform === 'linux';\n  exports.isIBMi = os.type() === 'OS400';\n})(constants);\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst {\n  promisify: promisify$2\n} = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\nconst statMethods$1 = {\n  lstat: lstat$1,\n  stat: stat$2\n};\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    });\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath));\n    }\n  };\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler,\n    // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async error => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE$2, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nlet NodeFsHandler$1 = class NodeFsHandler {\n  /**\n   * @param {import(\"../index\").FSWatcher} fsW\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n\n  /**\n   * Watch file for changes with fs_watchFile or fs_watch.\n   * @param {String} path to file or dir\n   * @param {Function} listener on fs change\n   * @returns {Function} closer for the watcher instance\n   */\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath$2.dirname(path);\n    const basename = sysPath$2.basename(path);\n    const parent = this.fsw._getWatchedDir(directory);\n    parent.add(basename);\n    const absolutePath = sysPath$2.resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN$2;\n    let closer;\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n    return closer;\n  }\n\n  /**\n   * Watch a file and emit add event if warranted.\n   * @param {Path} file Path\n   * @param {fs.Stats} stats result of fs_stat\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @returns {Function} closer for the watcher instance\n   */\n  _handleFile(file, stats, initialAdd) {\n    if (this.fsw.closed) {\n      return;\n    }\n    const dirname = sysPath$2.dirname(file);\n    const basename = sysPath$2.basename(file);\n    const parent = this.fsw._getWatchedDir(dirname);\n    // stats is always present\n    let prevStats = stats;\n\n    // if the file is already being watched, do nothing\n    if (parent.has(basename)) return;\n    const listener = async (path, newStats) => {\n      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n      if (!newStats || newStats.mtimeMs === 0) {\n        try {\n          const newStats = await stat$2(file);\n          if (this.fsw.closed) return;\n          // Check that change event was not fired because of changed only accessTime.\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE$2, file, newStats);\n          }\n          if (isLinux && prevStats.ino !== newStats.ino) {\n            this.fsw._closeFile(path);\n            prevStats = newStats;\n            this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n          } else {\n            prevStats = newStats;\n          }\n        } catch (error) {\n          // Fix issues where mtime is null but file is still present\n          this.fsw._remove(dirname, basename);\n        }\n        // add is about to be emitted if file not already tracked in parent\n      } else if (parent.has(basename)) {\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n        prevStats = newStats;\n      }\n    };\n    // kick off the watcher\n    const closer = this._watchWithNodeFs(file, listener);\n\n    // emit an add event if we're supposed to\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n      this.fsw._emit(EV_ADD$2, file, stats);\n    }\n    return closer;\n  }\n\n  /**\n   * Handle symlinks encountered while reading a dir.\n   * @param {Object} entry returned by readdirp\n   * @param {String} directory path of dir being read\n   * @param {String} path of this item\n   * @param {String} item basename of this item\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n   */\n  async _handleSymlink(entry, directory, path, item) {\n    if (this.fsw.closed) {\n      return;\n    }\n    const full = entry.fullPath;\n    const dir = this.fsw._getWatchedDir(directory);\n    if (!this.fsw.options.followSymlinks) {\n      // watch symlink directly (don't follow) and detect changes\n      this.fsw._incrReadyCount();\n      let linkPath;\n      try {\n        linkPath = await fsrealpath(path);\n      } catch (e) {\n        this.fsw._emitReady();\n        return true;\n      }\n      if (this.fsw.closed) return;\n      if (dir.has(item)) {\n        if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n          this.fsw._symlinkPaths.set(full, linkPath);\n          this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n        }\n      } else {\n        dir.add(item);\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_ADD$2, path, entry.stats);\n      }\n      this.fsw._emitReady();\n      return true;\n    }\n\n    // don't follow the same symlink more than once\n    if (this.fsw._symlinkPaths.has(full)) {\n      return true;\n    }\n    this.fsw._symlinkPaths.set(full, true);\n  }\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    // Normalize the directory name on Windows\n    directory = sysPath$2.join(directory, EMPTY_STR$1);\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n    const previous = this.fsw._getWatchedDir(wh.path);\n    const current = new Set();\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA$1, async entry => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const item = entry.path;\n      let path = sysPath$2.join(directory, item);\n      current.add(item);\n      if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n        return;\n      }\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n      if (item === target || !target && !previous.has(item)) {\n        this.fsw._incrReadyCount();\n\n        // ensure relativeness of path is preserved in case of watcher reuse\n        path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }).on(EV_ERROR$2, this._boundHandleError);\n    return new Promise(resolve => stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && (\n        // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath$2.resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n\n  /**\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\n   * @param {String} dir fs path\n   * @param {fs.Stats} stats\n   * @param {Boolean} initialAdd\n   * @param {Number} depth relative to user-supplied path\n   * @param {String} target child path targeted for watch\n   * @param {Object} wh Common watch helpers for this path\n   * @param {String} realpath\n   * @returns {Promise<Function>} closer for the watcher instance.\n   */\n  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n    const tracked = parentDir.has(sysPath$2.basename(dir));\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n      if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n    }\n\n    // ensure dir is tracked (harmless if redundant)\n    parentDir.add(sysPath$2.basename(dir));\n    this.fsw._getWatchedDir(dir);\n    let throttler;\n    let closer;\n    const oDepth = this.fsw.options.depth;\n    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n      if (!target) {\n        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n        if (this.fsw.closed) return;\n      }\n      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n        // if current directory is removed, do nothing\n        if (stats && stats.mtimeMs === 0) return;\n        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n      });\n    }\n    return closer;\n  }\n\n  /**\n   * Handle added file, directory, or glob pattern.\n   * Delegates call to _handleFile / _handleDir after checks.\n   * @param {String} path to file or ir\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @param {Object} priorWh depth relative to user-supplied path\n   * @param {Number} depth Child path actually targeted for watch\n   * @param {String=} target Child path actually targeted for watch\n   * @returns {Promise}\n   */\n  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    const ready = this.fsw._emitReady;\n    if (this.fsw._isIgnored(path) || this.fsw.closed) {\n      ready();\n      return false;\n    }\n    const wh = this.fsw._getWatchHelpers(path, depth);\n    if (!wh.hasGlob && priorWh) {\n      wh.hasGlob = priorWh.hasGlob;\n      wh.globFilter = priorWh.globFilter;\n      wh.filterPath = entry => priorWh.filterPath(entry);\n      wh.filterDir = entry => priorWh.filterDir(entry);\n    }\n\n    // evaluate what is at the path we're being asked to watch\n    try {\n      const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        ready();\n        return false;\n      }\n      const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n      let closer;\n      if (stats.isDirectory()) {\n        const absPath = sysPath$2.resolve(path);\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n        if (this.fsw.closed) return;\n        // preserve this symlink's target path\n        if (absPath !== targetPath && targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(absPath, targetPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        const parent = sysPath$2.dirname(wh.watchPath);\n        this.fsw._getWatchedDir(parent).add(wh.watchPath);\n        this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n        if (this.fsw.closed) return;\n\n        // preserve this symlink's target path\n        if (targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n        }\n      } else {\n        closer = this._handleFile(wh.watchPath, stats, initialAdd);\n      }\n      ready();\n      this.fsw._addPathCloser(path, closer);\n      return false;\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        ready();\n        return path;\n      }\n    }\n  }\n};\nvar nodefsHandler = NodeFsHandler$1;\nvar fseventsHandler = {\n  exports: {}\n};\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst {\n  promisify: promisify$1\n} = require$$2;\nlet fsevents;\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\nconst statMethods = {\n  stat: stat$1,\n  lstat\n};\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = path => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n\n/**\n * @mixin\n */\nlet FsEventsHandler$1 = class FsEventsHandler {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n      return true;\n    }\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat$1(path);\n      if (this.fsw.closed) return;\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n    if (event === EV_UNLINK$1) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n      // suppress unlink events on never before seen files\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD$1) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        }\n\n        // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n      this.fsw._emit(eventName, path);\n      if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n    }\n  }\n\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return;\n      // ensure directories are tracked\n      const parent = sysPath$1.dirname(path);\n      const item = sysPath$1.basename(path);\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent);\n\n      // correct for wrong events emitted\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE$1) {\n          let stats;\n          try {\n            stats = await stat$1(path);\n          } catch (error) {}\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n    this.fsw._emitReady();\n    return closer;\n  }\n\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n    this.fsw._symlinkPaths.set(fullPath, true);\n    this.fsw._incrReadyCount();\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n      this.fsw._incrReadyCount();\n\n      // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath$1.join(linkPath, path);\n        }\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n    const base = sysPath$1.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n    }\n  }\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath$1.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n    this.fsw._addPathCloser(path, closer);\n  }\n\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n    const wh = this.fsw._getWatchHelpers(path);\n\n    // evaluate what is at the path we're being asked to watch\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n        // don't recurse further if it would exceed depth setting\n        if (priorDepth && priorDepth > opts.depth) return;\n\n        // scan the contents of the dir\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n        this.fsw._emitReady();\n      }\n    }\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE$1) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n};\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\nvar fseventsHandlerExports = fseventsHandler.exports;\nconst {\n  EventEmitter\n} = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst {\n  promisify\n} = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatchExports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandlerExports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n  STR_CLOSE,\n  STR_END,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\nconst normalizeIgnored = (cwd = EMPTY_STR) => path => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n    return entry.fullPath;\n  }\n  entryPath(entry) {\n    return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    super();\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n    this._closers = new Map();\n    /** @type {Set<String>} */\n    this._ignoredPaths = new Set();\n\n    /** @type {Map<ThrottleType, Map>} */\n    this._throttled = new Map();\n\n    /** @type {Map<Path, String|Boolean>} */\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false;\n\n    // Set up default options.\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n    // Enable fsevents on OS X when polling isn't explicitly enabled.\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n    // If we can't use fsevents, ensure the options reflect it's disabled.\n    const canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false;\n\n    // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    }\n\n    // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n    if (isIBMi) {\n      opts.usePolling = true;\n    }\n\n    // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    }\n\n    // Editor atomic write normalization enabled by default with fs.watch\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n    this._emitReady = () => {\n      readyCalls++;\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN;\n        this._readyEmitted = true;\n        // use process.nextTick to allow time for listener to be bound\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n    this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n    this._readyEmitted = false;\n    this.options = opts;\n\n    // Initialize with proper watcher.\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new FsEventsHandler(this);\n    } else {\n      this._nodeFsHandler = new NodeFsHandler(this);\n    }\n\n    // Youre frozen when your hearts not open.\n    Object.freeze(opts);\n  }\n\n  // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd);\n\n        // Check `path` instead of `absPath` because the cwd portion can't be a glob\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n        return normalizePath(absPath);\n      });\n    }\n\n    // set aside negated glob strings\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG)) {\n        this._ignoredPaths.add(path.slice(1));\n        return false;\n      }\n\n      // if a path is being added that was previously ignored, stop ignoring it\n      this._ignoredPaths.delete(path);\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n      // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n      this._userIgnored = undefined;\n      return true;\n    });\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n        });\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath.join(cwd, path);\n        path = sysPath.resolve(path);\n      }\n      this._closePath(path);\n      this._ignoredPaths.add(path);\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      }\n\n      // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true;\n\n    // Memory management.\n    this.removeAllListeners();\n    const closers = [];\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n    this._streams.forEach(stream => stream.destroy());\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n    this._watched.forEach(dirent => dirent.dispose());\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n  getWatched() {\n    const watchList = {};\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n    return watchList;\n  }\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n  }\n\n  // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows) path = sysPath.normalize(path);\n    if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n    /** @type Array<any> */\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n    if (opts.atomic) {\n      if (event === EV_UNLINK) {\n        this._pendingUnlinks.set(path, args);\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n      if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE;\n        this._pendingUnlinks.delete(path);\n      }\n    }\n    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n          this.emitWithAll(event, args);\n        }\n      };\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n      return this;\n    }\n    if (event === EV_CHANGE) {\n      const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n      if (isThrottled) return this;\n    }\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n      let stats;\n      try {\n        stats = await stat(fullPath);\n      } catch (err) {}\n      // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n    this.emitWithAll(event, args);\n    return this;\n  }\n\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n  _handleError(error) {\n    const code = error && error.code;\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR, error);\n    }\n    return error || this.closed;\n  }\n\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n\n    /** @type {Map<Path, Object>} */\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n    const actionPath = action.get(path);\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n    let timeoutObject;\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n    if (this.options.cwd && !sysPath.isAbsolute(path)) {\n      fullPath = sysPath.join(this.options.cwd, path);\n    }\n    const now = new Date();\n    const awaitWriteFinish = prevStat => {\n      fs.stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n        const now = Number(new Date());\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n        const pw = this._pendingWrites.get(path);\n        const df = now - pw.lastChange;\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n    return this._userIgnored([path, stats]);\n  }\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  }\n\n  // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath.resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  }\n\n  // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true;\n\n    // stats.mode may be bigint\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath.join(directory, item);\n    const fullPath = sysPath.resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);\n\n    // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n    if (!this._throttle('remove', path, 100)) return;\n\n    // if the only watched file is removed, watch for its return\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    }\n\n    // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n    const wp = this._getWatchedDir(path);\n    const nestedDirectoryChildren = wp.getChildren();\n\n    // Recursively remove children directories / files.\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n    // Check if item was on the watched list and remove it\n    const parent = this._getWatchedDir(directory);\n    const wasTracked = parent.has(item);\n    parent.remove(item);\n\n    // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n    // but never removed from the map in case the path was deleted.\n    // This leads to an incorrect state if the path was recreated:\n    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n    if (this._symlinkPaths.has(fullPath)) {\n      this._symlinkPaths.delete(fullPath);\n    }\n\n    // If we wait for this file to be fully written, cancel the wait.\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n      if (event === EV_ADD) return;\n    }\n\n    // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n    this._watched.delete(path);\n    this._watched.delete(fullPath);\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n    // Avoid conflicts if we later create another file with the same name\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n  _closePath(path) {\n    this._closeFile(path);\n    const dir = sysPath.dirname(path);\n    this._getWatchedDir(dir).remove(sysPath.basename(path));\n  }\n\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n    if (!closers) return;\n    closers.forEach(closer => closer());\n    this._closers.delete(path);\n  }\n\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n    let list = this._closers.get(path);\n    if (!list) {\n      list = [];\n      this._closers.set(path, list);\n    }\n    list.push(closer);\n  }\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp(root, options);\n    this._streams.add(stream);\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END, () => {\n      if (stream) {\n        this._streams.delete(stream);\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n}\n\n// Export FSWatcher class\nchokidar.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\nchokidar.watch = watch;\nclass FileWatcher {\n  constructor(task, chokidarOptions) {\n    this.transformWatchers = new Map();\n    this.chokidarOptions = chokidarOptions;\n    this.task = task;\n    this.watcher = this.createWatcher(null);\n  }\n  close() {\n    this.watcher.close();\n    for (const watcher of this.transformWatchers.values()) {\n      watcher.close();\n    }\n  }\n  unwatch(id) {\n    this.watcher.unwatch(id);\n    const transformWatcher = this.transformWatchers.get(id);\n    if (transformWatcher) {\n      this.transformWatchers.delete(id);\n      transformWatcher.close();\n    }\n  }\n  watch(id, isTransformDependency) {\n    if (isTransformDependency) {\n      const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n      watcher.add(id);\n      this.transformWatchers.set(id, watcher);\n    } else {\n      this.watcher.add(id);\n    }\n  }\n  createWatcher(transformWatcherId) {\n    const task = this.task;\n    const isLinux = platform() === 'linux';\n    const isTransformDependency = transformWatcherId !== null;\n    const handleChange = (id, event) => {\n      const changedId = transformWatcherId || id;\n      if (isLinux) {\n        // unwatching and watching fixes an issue with chokidar where on certain systems,\n        // a file that was unlinked and immediately recreated would create a change event\n        // but then no longer any further events\n        watcher.unwatch(changedId);\n        watcher.add(changedId);\n      }\n      task.invalidate(changedId, {\n        event,\n        isTransformDependency\n      });\n    };\n    const watcher = chokidar.watch([], this.chokidarOptions).on('add', id => handleChange(id, 'create')).on('change', id => handleChange(id, 'update')).on('unlink', id => handleChange(id, 'delete'));\n    return watcher;\n  }\n}\nconst eventsRewrites = {\n  create: {\n    create: 'buggy',\n    delete: null,\n    update: 'create'\n  },\n  delete: {\n    create: 'update',\n    delete: 'buggy',\n    update: 'buggy'\n  },\n  update: {\n    create: 'buggy',\n    delete: 'delete',\n    update: 'update'\n  }\n};\nclass Watcher {\n  constructor(optionsList, emitter) {\n    this.buildDelay = 0;\n    this.buildTimeout = null;\n    this.closed = false;\n    this.invalidatedIds = new Map();\n    this.rerun = false;\n    this.running = true;\n    this.emitter = emitter;\n    emitter.close = this.close.bind(this);\n    this.tasks = optionsList.map(options => new Task(this, options));\n    for (const {\n      watch\n    } of optionsList) {\n      if (watch && typeof watch.buildDelay === 'number') {\n        this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n      }\n    }\n    process$1.nextTick(() => this.run());\n  }\n  async close() {\n    if (this.closed) return;\n    this.closed = true;\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    for (const task of this.tasks) {\n      task.close();\n    }\n    await this.emitter.emit('close');\n    this.emitter.removeAllListeners();\n  }\n  invalidate(file) {\n    if (file) {\n      const previousEvent = this.invalidatedIds.get(file.id);\n      const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n      if (event === 'buggy') {\n        //TODO: throws or warn? Currently just ignore, uses new event\n        this.invalidatedIds.set(file.id, file.event);\n      } else if (event === null) {\n        this.invalidatedIds.delete(file.id);\n      } else {\n        this.invalidatedIds.set(file.id, event);\n      }\n    }\n    if (this.running) {\n      this.rerun = true;\n      return;\n    }\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    this.buildTimeout = setTimeout(async () => {\n      this.buildTimeout = null;\n      try {\n        await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, {\n          event\n        })));\n        this.invalidatedIds.clear();\n        await this.emitter.emit('restart');\n        this.emitter.removeListenersForCurrentRun();\n        this.run();\n      } catch (error) {\n        this.invalidatedIds.clear();\n        await this.emitter.emit('event', {\n          code: 'ERROR',\n          error,\n          result: null\n        });\n        await this.emitter.emit('event', {\n          code: 'END'\n        });\n      }\n    }, this.buildDelay);\n  }\n  async run() {\n    this.running = true;\n    await this.emitter.emit('event', {\n      code: 'START'\n    });\n    for (const task of this.tasks) {\n      await task.run();\n    }\n    this.running = false;\n    await this.emitter.emit('event', {\n      code: 'END'\n    });\n    if (this.rerun) {\n      this.rerun = false;\n      this.invalidate();\n    }\n  }\n}\nclass Task {\n  constructor(watcher, options) {\n    this.cache = {\n      modules: []\n    };\n    this.watchFiles = [];\n    this.closed = false;\n    this.invalidated = true;\n    this.watched = new Set();\n    this.watcher = watcher;\n    this.options = options;\n    this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n    this.outputs = this.options.output;\n    this.outputFiles = this.outputs.map(output => {\n      if (output.file || output.dir) return resolve(output.file || output.dir);\n      return undefined;\n    });\n    const watchOptions = this.options.watch || {};\n    this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n    this.fileWatcher = new FileWatcher(this, {\n      ...watchOptions.chokidar,\n      disableGlobbing: true,\n      ignoreInitial: true\n    });\n  }\n  close() {\n    this.closed = true;\n    this.fileWatcher.close();\n  }\n  invalidate(id, details) {\n    this.invalidated = true;\n    if (details.isTransformDependency) {\n      for (const module of this.cache.modules) {\n        if (!module.transformDependencies.includes(id)) continue;\n        // effective invalidation\n        module.originalCode = null;\n      }\n    }\n    this.watcher.invalidate({\n      event: details.event,\n      id\n    });\n  }\n  async run() {\n    if (!this.invalidated) return;\n    this.invalidated = false;\n    const options = {\n      ...this.options,\n      cache: this.cache\n    };\n    const start = Date.now();\n    await this.watcher.emitter.emit('event', {\n      code: 'BUNDLE_START',\n      input: this.options.input,\n      output: this.outputFiles\n    });\n    let result = null;\n    try {\n      result = await rollupInternal(options, this.watcher.emitter);\n      if (this.closed) {\n        return;\n      }\n      this.updateWatchedFiles(result);\n      this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n      await this.watcher.emitter.emit('event', {\n        code: 'BUNDLE_END',\n        duration: Date.now() - start,\n        input: this.options.input,\n        output: this.outputFiles,\n        result\n      });\n    } catch (error) {\n      if (!this.closed) {\n        if (Array.isArray(error.watchFiles)) {\n          for (const id of error.watchFiles) {\n            this.watchFile(id);\n          }\n        }\n        if (error.id) {\n          this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n        }\n      }\n      await this.watcher.emitter.emit('event', {\n        code: 'ERROR',\n        error,\n        result\n      });\n    }\n  }\n  updateWatchedFiles(result) {\n    const previouslyWatched = this.watched;\n    this.watched = new Set();\n    this.watchFiles = result.watchFiles;\n    this.cache = result.cache;\n    for (const id of this.watchFiles) {\n      this.watchFile(id);\n    }\n    for (const module of this.cache.modules) {\n      for (const depId of module.transformDependencies) {\n        this.watchFile(depId, true);\n      }\n    }\n    for (const id of previouslyWatched) {\n      if (!this.watched.has(id)) {\n        this.fileWatcher.unwatch(id);\n      }\n    }\n  }\n  watchFile(id, isTransformDependency = false) {\n    if (!this.filter(id)) return;\n    this.watched.add(id);\n    if (this.outputFiles.includes(id)) {\n      throw new Error('Cannot import the generated bundle');\n    }\n    // this is necessary to ensure that any 'renamed' files\n    // continue to be watched following an error\n    this.fileWatcher.watch(id, isTransformDependency);\n  }\n}\nexport { Task, Watcher };","map":{"version":3,"names":["resolve","process$1","picomatch","picomatch$2","getAugmentedNamespace","fseventsImporter","createFilter","rollupInternal","platform","require$$0$1","require$$2","require$$1","require$$0$2","require$$2$1","require$$0$3","chokidar","fs$3","Readable","sysPath$3","promisify","promisify$3","picomatch$1","readdir$1","readdir","stat$3","stat","lstat$2","lstat","realpath$1","realpath","BANG$2","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","maj","min","process","versions","node","split","slice","map","n","Number","parseInt","wantBigintFsStats","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp$1","TypeError","readdirpPromise","reject","on","promise","default","readdirp_1","anymatch$2","exports","normalizePath$2","stripTrailing","prefix","ch","segs","anymatch_1","Object","defineProperty","value","normalizePath$1","BANG$1","DEFAULT_OPTIONS","returnIndex","arrify$1","createPattern","matcher","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","prototype","toString","call","index","nglob","applied","concat","pattern","anymatch$1","matchers","testString","mtchers","negatedGlobs","ri","anymatchExports","isExtglob$1","isExtglob","str","match","exec","chars","strictCheck","pipeIndex","closeSquareIndex","closeCurlyIndex","closeParenIndex","backSlashIndex","indexOf","open","close","relaxedCheck","isGlob$2","isGlob","check","strict","isGlob$1","pathPosixDirname","posix","dirname","isWin32","slash","backslash","enclosure","globby","escaped","globParent$1","globParent","assign","flipBackslashes","replace","utils$3","isInteger","num","find","nodes","exceedsLimit","max","step","limit","escapeNode","block","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","isOpenOrClose","reduce","acc","flatten","result","flat","arr","i","ele","utils$2","stringify$4","ast","stringify","invalidBlock","escapeInvalid","invalidNode","output","child","isNumber$2","isFinite","isNumber$1","toRegexRange$1","String","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","cache","hasOwnProperty","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","splitToRanges","nines","zeros","stop","countNines","stops","add","countZeros","sort","compare","rangeToPattern","start","count","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","tokens","prev","obj","toQuantifier","padZeros","comparison","intersection","contains","key","val","repeat","integer","pow","diff","clearCache","toRegexRange_1","util","toRegexRange","isObject","transform","toNumber","isValidValue","isNumber","input","stringify$3","end","pad","maxLength","dash","padStart","toMaxLen","toSequence","parts","toRange","isNumbers","fromCharCode","toRegex","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","format","range","fillLetters","charCodeAt","fill$2","fillRange","fill$1","utils$1","compile$1","walk","isOpen","isClose","compile_1","fill","stringify$2","utils","append","queue","stash","enclose","expand$1","rangeLimit","p","q","expand_1","constants$1","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","stringify$1","parse$1","SyntaxError","stack","brackets","advance","keepEscaping","next","keepQuotes","brace","shift","siblings","before","forEach","parse_1","compile","expand","parse","braces$1","create","nodupes","noempty","Boolean","braces_1","require$$0","binaryExtensions$1","binaryExtensions","extensions","isBinaryPath$1","filePath","extname","toLowerCase","constants","os","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_DATA","STR_END","STR_CLOSE","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_CLONED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","DOT_SLASH","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","STAR","GLOBSTAR","ROOT_GLOBSTAR","SLASH_GLOBSTAR","DIR_SUFFIX","ANYMATCH_OPTS","dot","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","IDENTITY_FN","isWindows","isMacos","isLinux","isIBMi","fs$2","sysPath$2","promisify$2","isBinaryPath","isWindows$1","EMPTY_FN$2","EMPTY_STR$1","EV_CHANGE$2","EV_ADD$2","EV_ADD_DIR$2","EV_ERROR$2","STR_DATA$1","STR_END$2","BRACE_START$1","THROTTLE_MODE_WATCH","stat$2","lstat$1","fsrealpath","statMethods$1","foreach","fn","addAndConvert","main","prop","container","clearItem","cont","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","watch","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","broadcastErr","watcherUnusable","fd","listeners","errHandlers","rawEmitters","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","currmtime","mtimeMs","NodeFsHandler$1","NodeFsHandler","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","directory","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","file","initialAdd","closed","prevStats","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","ignoreInitial","_isntIgnored","_handleSymlink","dir","followSymlinks","_incrReadyCount","linkPath","e","_emitReady","_symlinkPaths","_handleRead","wh","target","throttler","hasGlob","previous","current","stream","_readdirp","filterPath","filterDir","_addToNodeFs","once","wasThrottled","getChildren","_handleDir","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","watchPath","follow","absPath","targetPath","nodefsHandler","fseventsHandler","require$$3","fs$1","sysPath$1","promisify$1","fsevents","getFsEvents","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","EV_ADD$1","EV_CHANGE$1","EV_ADD_DIR$1","EV_UNLINK$1","EV_ERROR$1","STR_END$1","FUNCTION_TYPE$1","EMPTY_FN$1","Depth","isNaN","stat$1","statMethods","FSEventsWatchers","consolidateThreshhold","wrongEventFlags","createFSEventsInstance","callback","setFSEventsListener","realPath","parentPath","couldConsolidate","resolvedPath","hasSymlink","filteredListener","flags","info","watchedParent","keys","getInfo","list","event","lst","then","canUse","calcDepth","sameTypes","FsEventsHandler$1","FsEventsHandler","checkIgnored","ipaths","_ignoredPaths","addOrChange","watchedDir","checkExists","curDepth","_addToFsEvents","eventName","_watchWithFsEvents","watchCallback","ignored","_handleFsEventsSymlink","linkTarget","aliasedPath","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","base","initWatch","priorDepth","joinedPath","fseventsHandlerExports","EventEmitter","fs","sysPath","readdirp","anymatch","braces","normalizePath","arrify","unifyPaths","paths_","paths","every","normalizePathToUnix","toUnix","prepend","normalize","normalizeIgnored","cwd","isAbsolute","getAbsolutePath","undef","DirEntry","removeWatcher","_removeWatcher","items","remove","values","dispose","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","fullWatchPath","globSymlink","dirParts","getDirParts","checkGlobSymlink","fullParentDir","entryPath","matchesGlob","_hasReadPermissions","expandedPath","entryParts","globstar","unmatchedGlob","part","FSWatcher","_opts","_watched","_closers","_throttled","_streams","ignorePermissionErrors","disableGlobbing","useFsEvents","canUseFsEvents","envPoll","CHOKIDAR_USEPOLLING","envLower","envInterval","CHOKIDAR_INTERVAL","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","readyCalls","_readyCount","_readyEmitted","nextTick","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","_userIgnored","res","results","unwatch","_closePath","_closePromise","removeAllListeners","closers","closerList","getWatched","watchList","emitWithAll","pw","lastChange","Date","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","actionType","timeout","action","actionPath","timeoutObject","clearTimeout","thr","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","ign","_boundRemove","md","mode","st","it","wp","nestedDirectoryChildren","nested","wasTracked","relPath","FileWatcher","task","chokidarOptions","transformWatchers","createWatcher","id","transformWatcher","isTransformDependency","transformWatcherId","handleChange","changedId","invalidate","eventsRewrites","update","Watcher","optionsList","emitter","buildDelay","buildTimeout","invalidatedIds","rerun","running","tasks","Task","run","previousEvent","removeListenersForCurrentRun","modules","watchFiles","invalidated","watched","skipWrite","outputs","outputFiles","watchOptions","include","exclude","fileWatcher","details","module","transformDependencies","originalCode","updateWatchedFiles","write","duration","previouslyWatched","depId"],"sources":["C:/Users/100li/node_modules/rollup/dist/es/shared/watch.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v3.29.1\n\tSun, 10 Sep 2023 05:55:18 GMT - commit 40da6f85525c2ce48d9fd8d5c3579c41d8ef47a8\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { resolve } from 'node:path';\nimport process$1 from 'node:process';\nimport { picomatch as picomatch$2, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './node-entry.js';\nimport { platform } from 'node:os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$2 from 'path';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport 'node:perf_hooks';\nimport 'node:crypto';\nimport 'node:fs/promises';\nimport 'tty';\n\nvar chokidar = {};\n\nconst fs$3 = require$$0$1;\nconst { Readable } = require$$1;\nconst sysPath$3 = require$$0$2;\nconst { promisify: promisify$3 } = require$$2;\nconst picomatch$1 = picomatch$2;\n\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat$2 : stat$3;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = ('Dirent' in fs$3) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp$1 = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\n\nvar readdirp_1 = readdirp$1;\n\nvar anymatch$2 = {exports: {}};\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\nvar anymatch_1 = anymatch$2.exports;\n\nObject.defineProperty(anymatch_1, \"__esModule\", { value: true });\n\nconst picomatch = picomatch$2;\nconst normalizePath$1 = normalizePath$2;\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify$1 = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath$1(_path, false);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG$1)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG$1))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n\nvar anymatchExports = anymatch$2.exports;\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = isExtglob$1;\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n\n\texports.isInteger = num => {\n\t  if (typeof num === 'number') {\n\t    return Number.isInteger(num);\n\t  }\n\t  if (typeof num === 'string' && num.trim() !== '') {\n\t    return Number.isInteger(Number(num));\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.exceedsLimit = (min, max, step = 1, limit) => {\n\t  if (limit === false) return false;\n\t  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n\t  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n\t};\n\n\t/**\n\t * Escape the given node with '\\\\' before node.value\n\t */\n\n\texports.escapeNode = (block, n = 0, type) => {\n\t  let node = block.nodes[n];\n\t  if (!node) return;\n\n\t  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n\t    if (node.escaped !== true) {\n\t      node.value = '\\\\' + node.value;\n\t      node.escaped = true;\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Returns true if the given brace node should be enclosed in literal braces\n\t */\n\n\texports.encloseBrace = node => {\n\t  if (node.type !== 'brace') return false;\n\t  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n\t    node.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a brace node is invalid.\n\t */\n\n\texports.isInvalidBrace = block => {\n\t  if (block.type !== 'brace') return false;\n\t  if (block.invalid === true || block.dollar) return true;\n\t  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  if (block.open !== true || block.close !== true) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a node is an open or close node\n\t */\n\n\texports.isOpenOrClose = node => {\n\t  if (node.type === 'open' || node.type === 'close') {\n\t    return true;\n\t  }\n\t  return node.open === true || node.close === true;\n\t};\n\n\t/**\n\t * Reduce an array of text nodes.\n\t */\n\n\texports.reduce = nodes => nodes.reduce((acc, node) => {\n\t  if (node.type === 'text') acc.push(node.value);\n\t  if (node.type === 'range') node.type = 'text';\n\t  return acc;\n\t}, []);\n\n\t/**\n\t * Flatten an array\n\t */\n\n\texports.flatten = (...args) => {\n\t  const result = [];\n\t  const flat = arr => {\n\t    for (let i = 0; i < arr.length; i++) {\n\t      let ele = arr[i];\n\t      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n\t    }\n\t    return result;\n\t  };\n\t  flat(args);\n\t  return result;\n\t}; \n} (utils$3));\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber$2 = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange$1.cache = {};\ntoRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange$1;\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill$2 = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\n\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\n\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand$1 = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\n\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\nconst stringify$1 = stringify$4;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify$1(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nvar parse_1 = parse$1;\n\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces$1.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces$1.compile(input, options)\n    : braces$1.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces$1;\n\nconst require$$0 = [\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"appimage\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"flatpak\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"odp\",\n\t\"ods\",\n\t\"odt\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"ott\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rpm\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"snap\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n];\n\nvar binaryExtensions$1 = require$$0;\n\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1;\n\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n\n\tconst {sep} = require$$0$2;\n\tconst {platform} = process;\n\tconst os = require$$2$1;\n\n\texports.EV_ALL = 'all';\n\texports.EV_READY = 'ready';\n\texports.EV_ADD = 'add';\n\texports.EV_CHANGE = 'change';\n\texports.EV_ADD_DIR = 'addDir';\n\texports.EV_UNLINK = 'unlink';\n\texports.EV_UNLINK_DIR = 'unlinkDir';\n\texports.EV_RAW = 'raw';\n\texports.EV_ERROR = 'error';\n\n\texports.STR_DATA = 'data';\n\texports.STR_END = 'end';\n\texports.STR_CLOSE = 'close';\n\n\texports.FSEVENT_CREATED = 'created';\n\texports.FSEVENT_MODIFIED = 'modified';\n\texports.FSEVENT_DELETED = 'deleted';\n\texports.FSEVENT_MOVED = 'moved';\n\texports.FSEVENT_CLONED = 'cloned';\n\texports.FSEVENT_UNKNOWN = 'unknown';\n\texports.FSEVENT_TYPE_FILE = 'file';\n\texports.FSEVENT_TYPE_DIRECTORY = 'directory';\n\texports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\n\texports.KEY_LISTENERS = 'listeners';\n\texports.KEY_ERR = 'errHandlers';\n\texports.KEY_RAW = 'rawEmitters';\n\texports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\n\texports.DOT_SLASH = `.${sep}`;\n\n\texports.BACK_SLASH_RE = /\\\\/g;\n\texports.DOUBLE_SLASH_RE = /\\/\\//;\n\texports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n\texports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n\texports.REPLACER_RE = /^\\.[/\\\\]/;\n\n\texports.SLASH = '/';\n\texports.SLASH_SLASH = '//';\n\texports.BRACE_START = '{';\n\texports.BANG = '!';\n\texports.ONE_DOT = '.';\n\texports.TWO_DOTS = '..';\n\texports.STAR = '*';\n\texports.GLOBSTAR = '**';\n\texports.ROOT_GLOBSTAR = '/**/*';\n\texports.SLASH_GLOBSTAR = '/**';\n\texports.DIR_SUFFIX = 'Dir';\n\texports.ANYMATCH_OPTS = {dot: true};\n\texports.STRING_TYPE = 'string';\n\texports.FUNCTION_TYPE = 'function';\n\texports.EMPTY_STR = '';\n\texports.EMPTY_FN = () => {};\n\texports.IDENTITY_FN = val => val;\n\n\texports.isWindows = platform === 'win32';\n\texports.isMacos = platform === 'darwin';\n\texports.isLinux = platform === 'linux';\n\texports.isIBMi = os.type() === 'OS400'; \n} (constants));\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst { promisify: promisify$2 } = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\n\nconst statMethods$1 = { lstat: lstat$1, stat: stat$2 };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE$2, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nlet NodeFsHandler$1 = class NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath$2.dirname(path);\n  const basename = sysPath$2.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath$2.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN$2;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath$2.dirname(file);\n  const basename = sysPath$2.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat$2(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path);\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE$2, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  };\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n    this.fsw._emit(EV_ADD$2, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD$2, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA$1, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath$2.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR$2, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath$2.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n  const tracked = parentDir.has(sysPath$2.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath$2.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath$2.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath$2.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n};\n\nvar nodefsHandler = NodeFsHandler$1;\n\nvar fseventsHandler = {exports: {}};\n\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\n\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst { promisify: promisify$1 } = require$$2;\n\nlet fsevents;\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\n\nconst statMethods = { stat: stat$1, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath$1.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n);\n\n/**\n * @mixin\n */\nlet FsEventsHandler$1 = class FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat$1(path);\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK$1) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD$1) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath$1.join(\n      watchPath, sysPath$1.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath$1.dirname(path);\n    const item = sysPath$1.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE$1) {\n        let stats;\n        try {\n          stats = await stat$1(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath$1.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n  const base = sysPath$1.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath$1.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE$1) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n};\n\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\n\nvar fseventsHandlerExports = fseventsHandler.exports;\n\nconst { EventEmitter } = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst { promisify } = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatchExports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\n\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandlerExports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // Youre frozen when your hearts not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path);\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nchokidar.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\n\nclass FileWatcher {\n    constructor(task, chokidarOptions) {\n        this.transformWatchers = new Map();\n        this.chokidarOptions = chokidarOptions;\n        this.task = task;\n        this.watcher = this.createWatcher(null);\n    }\n    close() {\n        this.watcher.close();\n        for (const watcher of this.transformWatchers.values()) {\n            watcher.close();\n        }\n    }\n    unwatch(id) {\n        this.watcher.unwatch(id);\n        const transformWatcher = this.transformWatchers.get(id);\n        if (transformWatcher) {\n            this.transformWatchers.delete(id);\n            transformWatcher.close();\n        }\n    }\n    watch(id, isTransformDependency) {\n        if (isTransformDependency) {\n            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n            watcher.add(id);\n            this.transformWatchers.set(id, watcher);\n        }\n        else {\n            this.watcher.add(id);\n        }\n    }\n    createWatcher(transformWatcherId) {\n        const task = this.task;\n        const isLinux = platform() === 'linux';\n        const isTransformDependency = transformWatcherId !== null;\n        const handleChange = (id, event) => {\n            const changedId = transformWatcherId || id;\n            if (isLinux) {\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\n                // a file that was unlinked and immediately recreated would create a change event\n                // but then no longer any further events\n                watcher.unwatch(changedId);\n                watcher.add(changedId);\n            }\n            task.invalidate(changedId, { event, isTransformDependency });\n        };\n        const watcher = chokidar\n            .watch([], this.chokidarOptions)\n            .on('add', id => handleChange(id, 'create'))\n            .on('change', id => handleChange(id, 'update'))\n            .on('unlink', id => handleChange(id, 'delete'));\n        return watcher;\n    }\n}\n\nconst eventsRewrites = {\n    create: {\n        create: 'buggy',\n        delete: null,\n        update: 'create'\n    },\n    delete: {\n        create: 'update',\n        delete: 'buggy',\n        update: 'buggy'\n    },\n    update: {\n        create: 'buggy',\n        delete: 'delete',\n        update: 'update'\n    }\n};\nclass Watcher {\n    constructor(optionsList, emitter) {\n        this.buildDelay = 0;\n        this.buildTimeout = null;\n        this.closed = false;\n        this.invalidatedIds = new Map();\n        this.rerun = false;\n        this.running = true;\n        this.emitter = emitter;\n        emitter.close = this.close.bind(this);\n        this.tasks = optionsList.map(options => new Task(this, options));\n        for (const { watch } of optionsList) {\n            if (watch && typeof watch.buildDelay === 'number') {\n                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n            }\n        }\n        process$1.nextTick(() => this.run());\n    }\n    async close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        await this.emitter.emit('close');\n        this.emitter.removeAllListeners();\n    }\n    invalidate(file) {\n        if (file) {\n            const previousEvent = this.invalidatedIds.get(file.id);\n            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n            if (event === 'buggy') {\n                //TODO: throws or warn? Currently just ignore, uses new event\n                this.invalidatedIds.set(file.id, file.event);\n            }\n            else if (event === null) {\n                this.invalidatedIds.delete(file.id);\n            }\n            else {\n                this.invalidatedIds.set(file.id, event);\n            }\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(async () => {\n            this.buildTimeout = null;\n            try {\n                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));\n                this.invalidatedIds.clear();\n                await this.emitter.emit('restart');\n                this.emitter.removeListenersForCurrentRun();\n                this.run();\n            }\n            catch (error) {\n                this.invalidatedIds.clear();\n                await this.emitter.emit('event', {\n                    code: 'ERROR',\n                    error,\n                    result: null\n                });\n                await this.emitter.emit('event', {\n                    code: 'END'\n                });\n            }\n        }, this.buildDelay);\n    }\n    async run() {\n        this.running = true;\n        await this.emitter.emit('event', {\n            code: 'START'\n        });\n        for (const task of this.tasks) {\n            await task.run();\n        }\n        this.running = false;\n        await this.emitter.emit('event', {\n            code: 'END'\n        });\n        if (this.rerun) {\n            this.rerun = false;\n            this.invalidate();\n        }\n    }\n}\nclass Task {\n    constructor(watcher, options) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.closed = false;\n        this.invalidated = true;\n        this.watched = new Set();\n        this.watcher = watcher;\n        this.options = options;\n        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n        this.outputs = this.options.output;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return resolve(output.file || output.dir);\n            return undefined;\n        });\n        const watchOptions = this.options.watch || {};\n        this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n        this.fileWatcher = new FileWatcher(this, {\n            ...watchOptions.chokidar,\n            disableGlobbing: true,\n            ignoreInitial: true\n        });\n    }\n    close() {\n        this.closed = true;\n        this.fileWatcher.close();\n    }\n    invalidate(id, details) {\n        this.invalidated = true;\n        if (details.isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (!module.transformDependencies.includes(id))\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate({ event: details.event, id });\n    }\n    async run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = {\n            ...this.options,\n            cache: this.cache\n        };\n        const start = Date.now();\n        await this.watcher.emitter.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.options.input,\n            output: this.outputFiles\n        });\n        let result = null;\n        try {\n            result = await rollupInternal(options, this.watcher.emitter);\n            if (this.closed) {\n                return;\n            }\n            this.updateWatchedFiles(result);\n            this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n            await this.watcher.emitter.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.options.input,\n                output: this.outputFiles,\n                result\n            });\n        }\n        catch (error) {\n            if (!this.closed) {\n                if (Array.isArray(error.watchFiles)) {\n                    for (const id of error.watchFiles) {\n                        this.watchFile(id);\n                    }\n                }\n                if (error.id) {\n                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n                }\n            }\n            await this.watcher.emitter.emit('event', {\n                code: 'ERROR',\n                error,\n                result\n            });\n        }\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id)) {\n                this.fileWatcher.unwatch(id);\n            }\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.includes(id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        this.fileWatcher.watch(id, isTransformDependency);\n    }\n}\n\nexport { Task, Watcher };\n"],"mappings":"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EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,UAAU,EACV,KAAK,EACL,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,WAAW,EACX,WAAW,EACX,WAAW,EACX,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,MAAM,EACN,SAAS,EACT,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,IAAI,EACJ,KAAK,EACL,SAAS,EACT,IAAI,EACJ,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,SAAS,EACT,OAAO,EACP,GAAG,EACH,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}