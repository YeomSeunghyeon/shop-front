{"ast":null,"code":"import { E as getDefaultExportFromCjs } from './dep-df561101.js';\nimport require$$0 from 'path';\nimport require$$0__default from 'fs';\nimport { l as lib } from './dep-c423598f.js';\nimport { fileURLToPath as __cjs_fileURLToPath } from 'node:url';\nimport { dirname as __cjs_dirname } from 'node:path';\nimport { createRequire as __cjs_createRequire } from 'node:module';\nconst __filename = __cjs_fileURLToPath(import.meta.url);\nconst __dirname = __cjs_dirname(__filename);\nconst require = __cjs_createRequire(import.meta.url);\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) {\n      for (var k in e) {\n        if (k !== 'default' && !(k in n)) {\n          n[k] = e[k];\n        }\n      }\n    }\n  }\n  return n;\n}\nconst startsWithKeywordRegexp = /^(all|not|only|print|screen)/i;\nvar joinMedia$1 = function (parentMedia, childMedia) {\n  if (!parentMedia.length && childMedia.length) return childMedia;\n  if (parentMedia.length && !childMedia.length) return parentMedia;\n  if (!parentMedia.length && !childMedia.length) return [];\n  const media = [];\n  parentMedia.forEach(parentItem => {\n    const parentItemStartsWithKeyword = startsWithKeywordRegexp.test(parentItem);\n    childMedia.forEach(childItem => {\n      const childItemStartsWithKeyword = startsWithKeywordRegexp.test(childItem);\n      if (parentItem !== childItem) {\n        if (childItemStartsWithKeyword && !parentItemStartsWithKeyword) {\n          media.push(`${childItem} and ${parentItem}`);\n        } else {\n          media.push(`${parentItem} and ${childItem}`);\n        }\n      }\n    });\n  });\n  return media;\n};\nvar joinLayer$1 = function (parentLayer, childLayer) {\n  if (!parentLayer.length && childLayer.length) return childLayer;\n  if (parentLayer.length && !childLayer.length) return parentLayer;\n  if (!parentLayer.length && !childLayer.length) return [];\n  return parentLayer.concat(childLayer);\n};\nvar readCache$1 = {\n  exports: {}\n};\nvar pify$2 = {\n  exports: {}\n};\nvar processFn = function (fn, P, opts) {\n  return function () {\n    var that = this;\n    var args = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n    return new P(function (resolve, reject) {\n      args.push(function (err, result) {\n        if (err) {\n          reject(err);\n        } else if (opts.multiArgs) {\n          var results = new Array(arguments.length - 1);\n          for (var i = 1; i < arguments.length; i++) {\n            results[i - 1] = arguments[i];\n          }\n          resolve(results);\n        } else {\n          resolve(result);\n        }\n      });\n      fn.apply(that, args);\n    });\n  };\n};\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n  if (typeof P !== 'function') {\n    opts = P;\n    P = Promise;\n  }\n  opts = opts || {};\n  opts.exclude = opts.exclude || [/.+Sync$/];\n  var filter = function (key) {\n    var match = function (pattern) {\n      return typeof pattern === 'string' ? key === pattern : pattern.test(key);\n    };\n    return opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n  };\n  var ret = typeof obj === 'function' ? function () {\n    if (opts.excludeMain) {\n      return obj.apply(this, arguments);\n    }\n    return processFn(obj, P, opts).apply(this, arguments);\n  } : {};\n  return Object.keys(obj).reduce(function (ret, key) {\n    var x = obj[key];\n    ret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n    return ret;\n  }, ret);\n};\npify$1.all = pify$1;\nvar pifyExports = pify$2.exports;\nvar fs = require$$0__default;\nvar path$2 = require$$0;\nvar pify = pifyExports;\nvar stat = pify(fs.stat);\nvar readFile = pify(fs.readFile);\nvar resolve = path$2.resolve;\nvar cache = Object.create(null);\nfunction convert(content, encoding) {\n  if (Buffer.isEncoding(encoding)) {\n    return content.toString(encoding);\n  }\n  return content;\n}\nreadCache$1.exports = function (path, encoding) {\n  path = resolve(path);\n  return stat(path).then(function (stats) {\n    var item = cache[path];\n    if (item && item.mtime.getTime() === stats.mtime.getTime()) {\n      return convert(item.content, encoding);\n    }\n    return readFile(path).then(function (data) {\n      cache[path] = {\n        mtime: stats.mtime,\n        content: data\n      };\n      return convert(data, encoding);\n    });\n  }).catch(function (err) {\n    cache[path] = null;\n    return Promise.reject(err);\n  });\n};\nreadCache$1.exports.sync = function (path, encoding) {\n  path = resolve(path);\n  try {\n    var stats = fs.statSync(path);\n    var item = cache[path];\n    if (item && item.mtime.getTime() === stats.mtime.getTime()) {\n      return convert(item.content, encoding);\n    }\n    var data = fs.readFileSync(path);\n    cache[path] = {\n      mtime: stats.mtime,\n      content: data\n    };\n    return convert(data, encoding);\n  } catch (err) {\n    cache[path] = null;\n    throw err;\n  }\n};\nreadCache$1.exports.get = function (path, encoding) {\n  path = resolve(path);\n  if (cache[path]) {\n    return convert(cache[path].content, encoding);\n  }\n  return null;\n};\nreadCache$1.exports.clear = function () {\n  cache = Object.create(null);\n};\nvar readCacheExports = readCache$1.exports;\nconst dataURLRegexp = /^data:text\\/css;base64,/i;\nfunction isValid(url) {\n  return dataURLRegexp.test(url);\n}\nfunction contents(url) {\n  // \"data:text/css;base64,\".length === 21\n  return Buffer.from(url.slice(21), \"base64\").toString();\n}\nvar dataUrl = {\n  isValid,\n  contents\n};\nconst readCache = readCacheExports;\nconst dataURL$1 = dataUrl;\nvar loadContent$1 = filename => {\n  if (dataURL$1.isValid(filename)) {\n    return dataURL$1.contents(filename);\n  }\n  return readCache(filename, \"utf-8\");\n};\n\n// builtin tooling\nconst path$1 = require$$0;\n\n// placeholder tooling\nlet sugarss;\nvar processContent$1 = function processContent(result, content, filename, options, postcss) {\n  const {\n    plugins\n  } = options;\n  const ext = path$1.extname(filename);\n  const parserList = [];\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n    }\n    if (sugarss) return runPostcss(postcss, content, filename, plugins, [sugarss]);\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser);\n  // Try the default as a last resort:\n  parserList.push(null);\n  return runPostcss(postcss, content, filename, plugins, parserList);\n};\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins).process(content, {\n    from: filename,\n    parser: parsers[index]\n  }).catch(err => {\n    // If there's an error, try the next parser\n    index++;\n    // If there are no parsers left, throw it\n    if (index === parsers.length) throw err;\n    return runPostcss(postcss, content, filename, plugins, parsers, index);\n  });\n}\n\n// external tooling\nconst valueParser = lib;\n\n// extended tooling\nconst {\n  stringify\n} = valueParser;\nfunction split(params, start) {\n  const list = [];\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\";\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item);\n      return \"\";\n    }\n    return item + stringify(node);\n  }, \"\");\n  list.push(last);\n  return list;\n}\nvar parseStatements$1 = function (result, styles) {\n  const statements = [];\n  let nodes = [];\n  styles.each(node => {\n    let stmt;\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node);else if (node.name === \"media\") stmt = parseMedia(result, node);else if (node.name === \"charset\") stmt = parseCharset(result, node);\n    }\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: []\n        });\n        nodes = [];\n      }\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: []\n    });\n  }\n  return statements;\n};\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes;\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: []\n  };\n}\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule\n    });\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: []\n  };\n}\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev();\n  if (prev) {\n    do {\n      if (prev.type !== \"comment\" && (prev.type !== \"atrule\" || prev.name !== \"import\" && prev.name !== \"charset\" && !(prev.name === \"layer\" && !prev.nodes))) {\n        return result.warn(\"@import must precede all other statements (besides @charset or empty @layer)\", {\n          node: atRule\n        });\n      }\n      prev = prev.prev();\n    } while (prev);\n  }\n  if (atRule.nodes) {\n    return result.warn(\"It looks like you didn't end your @import statement correctly. \" + \"Child nodes are attached to it.\", {\n      node: atRule\n    });\n  }\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: []\n  };\n\n  // prettier-ignore\n  if (!params.length || (params[0].type !== \"string\" || !params[0].value) && (params[0].type !== \"function\" || params[0].value !== \"url\" || !params[0].nodes.length || !params[0].nodes[0].value)) {\n    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n      node: atRule\n    });\n  }\n  if (params[0].type === \"string\") stmt.uri = params[0].value;else stmt.uri = params[0].nodes[0].value;\n  stmt.fullUri = stringify(params[0]);\n  let remainder = params;\n  if (remainder.length > 2) {\n    if ((remainder[2].type === \"word\" || remainder[2].type === \"function\") && remainder[2].value === \"layer\") {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", {\n          node: atRule\n        });\n      }\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)];\n      } else {\n        stmt.layer = [\"\"];\n      }\n      remainder = remainder.slice(2);\n    }\n  }\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", {\n        node: atRule\n      });\n    }\n    stmt.media = split(remainder, 2);\n  }\n  return stmt;\n}\nvar assignLayerNames$1 = function (layer, node, state, options) {\n  layer.forEach((layerPart, i) => {\n    if (layerPart.trim() === \"\") {\n      if (options.nameLayer) {\n        layer[i] = options.nameLayer(state.anonymousLayerCounter++, state.rootFilename).toString();\n      } else {\n        throw node.error(`When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`);\n      }\n    }\n  });\n};\n\n// builtin tooling\nconst path = require$$0;\n\n// internal tooling\nconst joinMedia = joinMedia$1;\nconst joinLayer = joinLayer$1;\nconst resolveId = id => id;\nconst loadContent = loadContent$1;\nconst processContent = processContent$1;\nconst parseStatements = parseStatements$1;\nconst assignLayerNames = assignLayerNames$1;\nconst dataURL = dataUrl;\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options\n  };\n  options.root = path.resolve(options.root);\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path];\n  if (!Array.isArray(options.path)) options.path = [];\n  options.path = options.path.map(p => path.resolve(options.root, p));\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, {\n      result,\n      atRule,\n      postcss\n    }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0\n      };\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file;\n        state.importedFiles[styles.source.input.file] = {};\n      }\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\");\n      }\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\");\n      }\n      return parseStyles(result, styles, options, state, [], []).then(bundle => {\n        applyRaws(bundle);\n        applyMedia(bundle);\n        applyStyles(bundle, styles);\n      });\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return;\n          if (stmt.parent) {\n            const {\n              before\n            } = stmt.parent.node.raws;\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;else stmt.node.raws.before = before;\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n          }\n        });\n      }\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (!stmt.media.length && !stmt.layer.length || stmt.type === \"charset\") {\n            return;\n          }\n          if (stmt.layer.length > 1) {\n            assignLayerNames(stmt.layer, stmt.node, state, options);\n          }\n          if (stmt.type === \"import\") {\n            const parts = [stmt.fullUri];\n            const media = stmt.media.join(\", \");\n            if (stmt.layer.length) {\n              const layerName = stmt.layer.join(\".\");\n              let layerParams = \"layer\";\n              if (layerName) {\n                layerParams = `layer(${layerName})`;\n              }\n              parts.push(layerParams);\n            }\n            if (media) {\n              parts.push(media);\n            }\n            stmt.node.params = parts.join(\" \");\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: stmt.node.source\n              });\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source\n                });\n                mediaNode.append(layerNode);\n                layerNode.append(stmt.node);\n                stmt.node = mediaNode;\n              } else {\n                layerNode.append(stmt.node);\n                stmt.node = layerNode;\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \");\n            }\n          } else {\n            const {\n              nodes\n            } = stmt;\n            const {\n              parent\n            } = nodes[0];\n            let outerAtRule;\n            let innerAtRule;\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source\n              });\n              mediaNode.append(layerNode);\n              innerAtRule = layerNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source\n              });\n              innerAtRule = mediaNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source\n              });\n              innerAtRule = layerNode;\n              outerAtRule = layerNode;\n            }\n            parent.insertBefore(nodes[0], outerAtRule);\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined;\n            });\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes);\n            stmt.type = \"media\";\n            stmt.node = outerAtRule;\n            delete stmt.nodes;\n          }\n        });\n      }\n      function applyStyles(bundle, styles) {\n        styles.nodes = [];\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined;\n            styles.append(stmt.node);\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined;\n              styles.append(node);\n            });\n          }\n        });\n      }\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles);\n        return Promise.resolve(statements).then(stmts => {\n          // process each statement in series\n          return stmts.reduce((promise, stmt) => {\n            return promise.then(() => {\n              stmt.media = joinMedia(media, stmt.media || []);\n              stmt.parentMedia = media;\n              stmt.layer = joinLayer(layer, stmt.layer || []);\n\n              // skip protocol base uri (protocol://url) or protocol-relative\n              if (stmt.type !== \"import\" || /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)) {\n                return;\n              }\n              if (options.filter && !options.filter(stmt.uri)) {\n                // rejected by filter\n                return;\n              }\n              return resolveImportId(result, stmt, options, state);\n            });\n          }, Promise.resolve());\n        }).then(() => {\n          let charset;\n          const imports = [];\n          const bundle = [];\n          function handleCharset(stmt) {\n            if (!charset) charset = stmt;\n            // charsets aren't case-sensitive, so convert to lower case to compare\n            else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {\n              throw new Error(`Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`);\n            }\n          }\n\n          // squash statements and their children\n          statements.forEach(stmt => {\n            if (stmt.type === \"charset\") handleCharset(stmt);else if (stmt.type === \"import\") {\n              if (stmt.children) {\n                stmt.children.forEach((child, index) => {\n                  if (child.type === \"import\") imports.push(child);else if (child.type === \"charset\") handleCharset(child);else bundle.push(child);\n                  // For better output\n                  if (index === 0) child.parent = stmt;\n                });\n              } else imports.push(stmt);\n            } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n              bundle.push(stmt);\n            }\n          });\n          return charset ? [charset, ...imports.concat(bundle)] : imports.concat(bundle);\n        });\n      }\n      function resolveImportId(result, stmt, options, state) {\n        if (dataURL.isValid(stmt.uri)) {\n          return loadImportContent(result, stmt, stmt.uri, options, state).then(result => {\n            stmt.children = result;\n          });\n        }\n        const atRule = stmt.node;\n        let sourceFile;\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file;\n        }\n        const base = sourceFile ? path.dirname(atRule.source.input.file) : options.root;\n        return Promise.resolve(options.resolve(stmt.uri, base, options)).then(paths => {\n          if (!Array.isArray(paths)) paths = [paths];\n          // Ensure that each path is absolute:\n          return Promise.all(paths.map(file => {\n            return !path.isAbsolute(file) ? resolveId(file) : file;\n          }));\n        }).then(resolved => {\n          // Add dependency messages:\n          resolved.forEach(file => {\n            result.messages.push({\n              type: \"dependency\",\n              plugin: \"postcss-import\",\n              file,\n              parent: sourceFile\n            });\n          });\n          return Promise.all(resolved.map(file => {\n            return loadImportContent(result, stmt, file, options, state);\n          }));\n        }).then(result => {\n          // Merge loaded statements\n          stmt.children = result.reduce((result, statements) => {\n            return statements ? result.concat(statements) : result;\n          }, []);\n        });\n      }\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node;\n        const {\n          media,\n          layer\n        } = stmt;\n        assignLayerNames(layer, atRule, state, options);\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return;\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {};\n          }\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {};\n          }\n          state.importedFiles[filename][media][layer] = true;\n        }\n        return Promise.resolve(options.load(filename, options)).then(content => {\n          if (content.trim() === \"\") {\n            result.warn(`${filename} is empty`, {\n              node: atRule\n            });\n            return;\n          }\n\n          // skip previous imported files not containing @import rules\n          if (state.hashFiles[content]?.[media]?.[layer]) {\n            return;\n          }\n          return processContent(result, content, filename, options, postcss).then(importedResult => {\n            const styles = importedResult.root;\n            result.messages = result.messages.concat(importedResult.messages);\n            if (options.skipDuplicates) {\n              const hasImport = styles.some(child => {\n                return child.type === \"atrule\" && child.name === \"import\";\n              });\n              if (!hasImport) {\n                // save hash files to skip them next time\n                if (!state.hashFiles[content]) {\n                  state.hashFiles[content] = {};\n                }\n                if (!state.hashFiles[content][media]) {\n                  state.hashFiles[content][media] = {};\n                }\n                state.hashFiles[content][media][layer] = true;\n              }\n            }\n\n            // recursion: import @import from imported file\n            return parseStyles(result, styles, options, state, media, layer);\n          });\n        });\n      }\n    }\n  };\n}\nAtImport.postcss = true;\nvar postcssImport = AtImport;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postcssImport);\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [postcssImport]);\nexport { index$1 as i };","map":{"version":3,"names":["E","getDefaultExportFromCjs","require$$0","require$$0__default","l","lib","fileURLToPath","__cjs_fileURLToPath","dirname","__cjs_dirname","createRequire","__cjs_createRequire","__filename","import","meta","url","__dirname","require","__require","_mergeNamespaces","n","m","i","length","e","Array","isArray","k","startsWithKeywordRegexp","joinMedia$1","parentMedia","childMedia","media","forEach","parentItem","parentItemStartsWithKeyword","test","childItem","childItemStartsWithKeyword","push","joinLayer$1","parentLayer","childLayer","concat","readCache$1","exports","pify$2","processFn","fn","P","opts","that","args","arguments","resolve","reject","err","result","multiArgs","results","apply","pify$1","obj","Promise","exclude","filter","key","match","pattern","include","some","ret","excludeMain","Object","keys","reduce","x","all","pifyExports","fs","path$2","pify","stat","readFile","cache","create","convert","content","encoding","Buffer","isEncoding","toString","path","then","stats","item","mtime","getTime","data","catch","sync","statSync","readFileSync","get","clear","readCacheExports","dataURLRegexp","isValid","contents","from","slice","dataUrl","readCache","dataURL$1","loadContent$1","filename","path$1","sugarss","processContent$1","processContent","options","postcss","plugins","ext","extname","parserList","runPostcss","syntax","parse","parser","parsers","index","process","valueParser","stringify","split","params","start","list","last","node","type","value","parseStatements$1","styles","statements","nodes","each","stmt","name","parseImport","parseMedia","parseCharset","layer","atRule","prev","warn","uri","fullUri","remainder","assignLayerNames$1","state","layerPart","trim","nameLayer","anonymousLayerCounter","rootFilename","error","joinMedia","joinLayer","resolveId","id","loadContent","parseStatements","assignLayerNames","dataURL","AtImport","root","cwd","skipDuplicates","load","addModulesDirectories","map","p","postcssPlugin","Once","importedFiles","hashFiles","source","input","file","Error","parseStyles","bundle","applyRaws","applyMedia","applyStyles","parent","before","raws","parts","join","layerName","layerParams","layerNode","mediaNode","append","outerAtRule","innerAtRule","insertBefore","undefined","includes","stmts","promise","resolveImportId","charset","imports","handleCharset","toLowerCase","children","child","loadImportContent","sourceFile","base","paths","isAbsolute","resolved","messages","plugin","importedResult","hasImport","postcssImport","index$1","__proto__","default"],"sources":["C:/Users/100li/node_modules/vite/dist/node/chunks/dep-e0331088.js"],"sourcesContent":["import { E as getDefaultExportFromCjs } from './dep-df561101.js';\nimport require$$0 from 'path';\nimport require$$0__default from 'fs';\nimport { l as lib } from './dep-c423598f.js';\n\nimport { fileURLToPath as __cjs_fileURLToPath } from 'node:url';\nimport { dirname as __cjs_dirname } from 'node:path';\nimport { createRequire as __cjs_createRequire } from 'node:module';\n\nconst __filename = __cjs_fileURLToPath(import.meta.url);\nconst __dirname = __cjs_dirname(__filename);\nconst require = __cjs_createRequire(import.meta.url);\nconst __require = require;\nfunction _mergeNamespaces(n, m) {\n  for (var i = 0; i < m.length; i++) {\n    var e = m[i];\n    if (typeof e !== 'string' && !Array.isArray(e)) { for (var k in e) {\n      if (k !== 'default' && !(k in n)) {\n        n[k] = e[k];\n      }\n    } }\n  }\n  return n;\n}\n\nconst startsWithKeywordRegexp = /^(all|not|only|print|screen)/i;\n\nvar joinMedia$1 = function (parentMedia, childMedia) {\n  if (!parentMedia.length && childMedia.length) return childMedia\n  if (parentMedia.length && !childMedia.length) return parentMedia\n  if (!parentMedia.length && !childMedia.length) return []\n\n  const media = [];\n\n  parentMedia.forEach(parentItem => {\n    const parentItemStartsWithKeyword = startsWithKeywordRegexp.test(parentItem);\n\n    childMedia.forEach(childItem => {\n      const childItemStartsWithKeyword = startsWithKeywordRegexp.test(childItem);\n      if (parentItem !== childItem) {\n        if (childItemStartsWithKeyword && !parentItemStartsWithKeyword) {\n          media.push(`${childItem} and ${parentItem}`);\n        } else {\n          media.push(`${parentItem} and ${childItem}`);\n        }\n      }\n    });\n  });\n\n  return media\n};\n\nvar joinLayer$1 = function (parentLayer, childLayer) {\n  if (!parentLayer.length && childLayer.length) return childLayer\n  if (parentLayer.length && !childLayer.length) return parentLayer\n  if (!parentLayer.length && !childLayer.length) return []\n\n  return parentLayer.concat(childLayer)\n};\n\nvar readCache$1 = {exports: {}};\n\nvar pify$2 = {exports: {}};\n\nvar processFn = function (fn, P, opts) {\n\treturn function () {\n\t\tvar that = this;\n\t\tvar args = new Array(arguments.length);\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\n\t\treturn new P(function (resolve, reject) {\n\t\t\targs.push(function (err, result) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else if (opts.multiArgs) {\n\t\t\t\t\tvar results = new Array(arguments.length - 1);\n\n\t\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\t\tresults[i - 1] = arguments[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(results);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfn.apply(that, args);\n\t\t});\n\t};\n};\n\nvar pify$1 = pify$2.exports = function (obj, P, opts) {\n\tif (typeof P !== 'function') {\n\t\topts = P;\n\t\tP = Promise;\n\t}\n\n\topts = opts || {};\n\topts.exclude = opts.exclude || [/.+Sync$/];\n\n\tvar filter = function (key) {\n\t\tvar match = function (pattern) {\n\t\t\treturn typeof pattern === 'string' ? key === pattern : pattern.test(key);\n\t\t};\n\n\t\treturn opts.include ? opts.include.some(match) : !opts.exclude.some(match);\n\t};\n\n\tvar ret = typeof obj === 'function' ? function () {\n\t\tif (opts.excludeMain) {\n\t\t\treturn obj.apply(this, arguments);\n\t\t}\n\n\t\treturn processFn(obj, P, opts).apply(this, arguments);\n\t} : {};\n\n\treturn Object.keys(obj).reduce(function (ret, key) {\n\t\tvar x = obj[key];\n\n\t\tret[key] = typeof x === 'function' && filter(key) ? processFn(x, P, opts) : x;\n\n\t\treturn ret;\n\t}, ret);\n};\n\npify$1.all = pify$1;\n\nvar pifyExports = pify$2.exports;\n\nvar fs = require$$0__default;\r\nvar path$2 = require$$0;\r\nvar pify = pifyExports;\r\n\r\nvar stat = pify(fs.stat);\r\nvar readFile = pify(fs.readFile);\r\nvar resolve = path$2.resolve;\r\n\r\nvar cache = Object.create(null);\r\n\r\nfunction convert(content, encoding) {\r\n\tif (Buffer.isEncoding(encoding)) {\r\n\t\treturn content.toString(encoding);\r\n\t}\r\n\treturn content;\r\n}\r\n\r\nreadCache$1.exports = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\treturn stat(path).then(function (stats) {\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\treturn readFile(path).then(function (data) {\r\n\t\t\tcache[path] = {\r\n\t\t\t\tmtime: stats.mtime,\r\n\t\t\t\tcontent: data\r\n\t\t\t};\r\n\r\n\t\t\treturn convert(data, encoding);\r\n\t\t});\r\n\t}).catch(function (err) {\r\n\t\tcache[path] = null;\r\n\t\treturn Promise.reject(err);\r\n\t});\r\n};\r\n\r\nreadCache$1.exports.sync = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\r\n\ttry {\r\n\t\tvar stats = fs.statSync(path);\r\n\t\tvar item = cache[path];\r\n\r\n\t\tif (item && item.mtime.getTime() === stats.mtime.getTime()) {\r\n\t\t\treturn convert(item.content, encoding);\r\n\t\t}\r\n\r\n\t\tvar data = fs.readFileSync(path);\r\n\r\n\t\tcache[path] = {\r\n\t\t\tmtime: stats.mtime,\r\n\t\t\tcontent: data\r\n\t\t};\r\n\r\n\t\treturn convert(data, encoding);\r\n\t} catch (err) {\r\n\t\tcache[path] = null;\r\n\t\tthrow err;\r\n\t}\r\n\r\n};\r\n\r\nreadCache$1.exports.get = function (path, encoding) {\r\n\tpath = resolve(path);\r\n\tif (cache[path]) {\r\n\t\treturn convert(cache[path].content, encoding);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nreadCache$1.exports.clear = function () {\r\n\tcache = Object.create(null);\r\n};\n\nvar readCacheExports = readCache$1.exports;\n\nconst dataURLRegexp = /^data:text\\/css;base64,/i;\n\nfunction isValid(url) {\n  return dataURLRegexp.test(url)\n}\n\nfunction contents(url) {\n  // \"data:text/css;base64,\".length === 21\n  return Buffer.from(url.slice(21), \"base64\").toString()\n}\n\nvar dataUrl = {\n  isValid,\n  contents,\n};\n\nconst readCache = readCacheExports;\nconst dataURL$1 = dataUrl;\n\nvar loadContent$1 = filename => {\n  if (dataURL$1.isValid(filename)) {\n    return dataURL$1.contents(filename)\n  }\n\n  return readCache(filename, \"utf-8\")\n};\n\n// builtin tooling\nconst path$1 = require$$0;\n\n// placeholder tooling\nlet sugarss;\n\nvar processContent$1 = function processContent(\n  result,\n  content,\n  filename,\n  options,\n  postcss\n) {\n  const { plugins } = options;\n  const ext = path$1.extname(filename);\n\n  const parserList = [];\n\n  // SugarSS support:\n  if (ext === \".sss\") {\n    if (!sugarss) {\n      try {\n        sugarss = __require('sugarss');\n      } catch {} // Ignore\n    }\n    if (sugarss)\n      return runPostcss(postcss, content, filename, plugins, [sugarss])\n  }\n\n  // Syntax support:\n  if (result.opts.syntax?.parse) {\n    parserList.push(result.opts.syntax.parse);\n  }\n\n  // Parser support:\n  if (result.opts.parser) parserList.push(result.opts.parser);\n  // Try the default as a last resort:\n  parserList.push(null);\n\n  return runPostcss(postcss, content, filename, plugins, parserList)\n};\n\nfunction runPostcss(postcss, content, filename, plugins, parsers, index) {\n  if (!index) index = 0;\n  return postcss(plugins)\n    .process(content, {\n      from: filename,\n      parser: parsers[index],\n    })\n    .catch(err => {\n      // If there's an error, try the next parser\n      index++;\n      // If there are no parsers left, throw it\n      if (index === parsers.length) throw err\n      return runPostcss(postcss, content, filename, plugins, parsers, index)\n    })\n}\n\n// external tooling\nconst valueParser = lib;\n\n// extended tooling\nconst { stringify } = valueParser;\n\nfunction split(params, start) {\n  const list = [];\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\"\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item);\n      return \"\"\n    }\n    return item + stringify(node)\n  }, \"\");\n  list.push(last);\n  return list\n}\n\nvar parseStatements$1 = function (result, styles) {\n  const statements = [];\n  let nodes = [];\n\n  styles.each(node => {\n    let stmt;\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node);\n      else if (node.name === \"media\") stmt = parseMedia(result, node);\n      else if (node.name === \"charset\") stmt = parseCharset(result, node);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: [],\n        });\n        nodes = [];\n      }\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: [],\n    });\n  }\n\n  return statements\n};\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes;\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: [],\n  }\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev();\n  if (prev) {\n    do {\n      if (\n        prev.type !== \"comment\" &&\n        (prev.type !== \"atrule\" ||\n          (prev.name !== \"import\" &&\n            prev.name !== \"charset\" &&\n            !(prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        return result.warn(\n          \"@import must precede all other statements (besides @charset or empty @layer)\",\n          { node: atRule }\n        )\n      }\n      prev = prev.prev();\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule }\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: [],\n  };\n\n  // prettier-ignore\n  if (\n    !params.length ||\n    (\n      params[0].type !== \"string\" ||\n      !params[0].value\n    ) &&\n    (\n      params[0].type !== \"function\" ||\n      params[0].value !== \"url\" ||\n      !params[0].nodes.length ||\n      !params[0].nodes[0].value\n    )\n  ) {\n    return result.warn(`Unable to find uri in '${  atRule.toString()  }'`, {\n      node: atRule,\n    })\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value;\n  else stmt.uri = params[0].nodes[0].value;\n  stmt.fullUri = stringify(params[0]);\n\n  let remainder = params;\n  if (remainder.length > 2) {\n    if (\n      (remainder[2].type === \"word\" || remainder[2].type === \"function\") &&\n      remainder[2].value === \"layer\"\n    ) {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", { node: atRule })\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)];\n      } else {\n        stmt.layer = [\"\"];\n      }\n      remainder = remainder.slice(2);\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", { node: atRule })\n    }\n\n    stmt.media = split(remainder, 2);\n  }\n\n  return stmt\n}\n\nvar assignLayerNames$1 = function (layer, node, state, options) {\n  layer.forEach((layerPart, i) => {\n    if (layerPart.trim() === \"\") {\n      if (options.nameLayer) {\n        layer[i] = options\n          .nameLayer(state.anonymousLayerCounter++, state.rootFilename)\n          .toString();\n      } else {\n        throw node.error(\n          `When using anonymous layers in @import you must also set the \"nameLayer\" plugin option`\n        )\n      }\n    }\n  });\n};\n\n// builtin tooling\nconst path = require$$0;\n\n// internal tooling\nconst joinMedia = joinMedia$1;\nconst joinLayer = joinLayer$1;\nconst resolveId = (id) => id;\nconst loadContent = loadContent$1;\nconst processContent = processContent$1;\nconst parseStatements = parseStatements$1;\nconst assignLayerNames = assignLayerNames$1;\nconst dataURL = dataUrl;\n\nfunction AtImport(options) {\n  options = {\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: [],\n    nameLayer: null,\n    ...options,\n  };\n\n  options.root = path.resolve(options.root);\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path];\n\n  if (!Array.isArray(options.path)) options.path = [];\n\n  options.path = options.path.map(p => path.resolve(options.root, p));\n\n  return {\n    postcssPlugin: \"postcss-import\",\n    Once(styles, { result, atRule, postcss }) {\n      const state = {\n        importedFiles: {},\n        hashFiles: {},\n        rootFilename: null,\n        anonymousLayerCounter: 0,\n      };\n\n      if (styles.source?.input?.file) {\n        state.rootFilename = styles.source.input.file;\n        state.importedFiles[styles.source.input.file] = {};\n      }\n\n      if (options.plugins && !Array.isArray(options.plugins)) {\n        throw new Error(\"plugins option must be an array\")\n      }\n\n      if (options.nameLayer && typeof options.nameLayer !== \"function\") {\n        throw new Error(\"nameLayer option must be a function\")\n      }\n\n      return parseStyles(result, styles, options, state, [], []).then(\n        bundle => {\n          applyRaws(bundle);\n          applyMedia(bundle);\n          applyStyles(bundle, styles);\n        }\n      )\n\n      function applyRaws(bundle) {\n        bundle.forEach((stmt, index) => {\n          if (index === 0) return\n\n          if (stmt.parent) {\n            const { before } = stmt.parent.node.raws;\n            if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;\n            else stmt.node.raws.before = before;\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n          }\n        });\n      }\n\n      function applyMedia(bundle) {\n        bundle.forEach(stmt => {\n          if (\n            (!stmt.media.length && !stmt.layer.length) ||\n            stmt.type === \"charset\"\n          ) {\n            return\n          }\n\n          if (stmt.layer.length > 1) {\n            assignLayerNames(stmt.layer, stmt.node, state, options);\n          }\n\n          if (stmt.type === \"import\") {\n            const parts = [stmt.fullUri];\n\n            const media = stmt.media.join(\", \");\n\n            if (stmt.layer.length) {\n              const layerName = stmt.layer.join(\".\");\n\n              let layerParams = \"layer\";\n              if (layerName) {\n                layerParams = `layer(${layerName})`;\n              }\n\n              parts.push(layerParams);\n            }\n\n            if (media) {\n              parts.push(media);\n            }\n\n            stmt.node.params = parts.join(\" \");\n          } else if (stmt.type === \"media\") {\n            if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: stmt.node.source,\n              });\n\n              if (stmt.parentMedia?.length) {\n                const mediaNode = atRule({\n                  name: \"media\",\n                  params: stmt.parentMedia.join(\", \"),\n                  source: stmt.node.source,\n                });\n\n                mediaNode.append(layerNode);\n                layerNode.append(stmt.node);\n                stmt.node = mediaNode;\n              } else {\n                layerNode.append(stmt.node);\n                stmt.node = layerNode;\n              }\n            } else {\n              stmt.node.params = stmt.media.join(\", \");\n            }\n          } else {\n            const { nodes } = stmt;\n            const { parent } = nodes[0];\n\n            let outerAtRule;\n            let innerAtRule;\n            if (stmt.media.length && stmt.layer.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              });\n\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              });\n\n              mediaNode.append(layerNode);\n              innerAtRule = layerNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.media.length) {\n              const mediaNode = atRule({\n                name: \"media\",\n                params: stmt.media.join(\", \"),\n                source: parent.source,\n              });\n\n              innerAtRule = mediaNode;\n              outerAtRule = mediaNode;\n            } else if (stmt.layer.length) {\n              const layerNode = atRule({\n                name: \"layer\",\n                params: stmt.layer.join(\".\"),\n                source: parent.source,\n              });\n\n              innerAtRule = layerNode;\n              outerAtRule = layerNode;\n            }\n\n            parent.insertBefore(nodes[0], outerAtRule);\n\n            // remove nodes\n            nodes.forEach(node => {\n              node.parent = undefined;\n            });\n\n            // better output\n            nodes[0].raws.before = nodes[0].raws.before || \"\\n\";\n\n            // wrap new rules with media query and/or layer at rule\n            innerAtRule.append(nodes);\n\n            stmt.type = \"media\";\n            stmt.node = outerAtRule;\n            delete stmt.nodes;\n          }\n        });\n      }\n\n      function applyStyles(bundle, styles) {\n        styles.nodes = [];\n\n        // Strip additional statements.\n        bundle.forEach(stmt => {\n          if ([\"charset\", \"import\", \"media\"].includes(stmt.type)) {\n            stmt.node.parent = undefined;\n            styles.append(stmt.node);\n          } else if (stmt.type === \"nodes\") {\n            stmt.nodes.forEach(node => {\n              node.parent = undefined;\n              styles.append(node);\n            });\n          }\n        });\n      }\n\n      function parseStyles(result, styles, options, state, media, layer) {\n        const statements = parseStatements(result, styles);\n\n        return Promise.resolve(statements)\n          .then(stmts => {\n            // process each statement in series\n            return stmts.reduce((promise, stmt) => {\n              return promise.then(() => {\n                stmt.media = joinMedia(media, stmt.media || []);\n                stmt.parentMedia = media;\n                stmt.layer = joinLayer(layer, stmt.layer || []);\n\n                // skip protocol base uri (protocol://url) or protocol-relative\n                if (\n                  stmt.type !== \"import\" ||\n                  /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)\n                ) {\n                  return\n                }\n\n                if (options.filter && !options.filter(stmt.uri)) {\n                  // rejected by filter\n                  return\n                }\n\n                return resolveImportId(result, stmt, options, state)\n              })\n            }, Promise.resolve())\n          })\n          .then(() => {\n            let charset;\n            const imports = [];\n            const bundle = [];\n\n            function handleCharset(stmt) {\n              if (!charset) charset = stmt;\n              // charsets aren't case-sensitive, so convert to lower case to compare\n              else if (\n                stmt.node.params.toLowerCase() !==\n                charset.node.params.toLowerCase()\n              ) {\n                throw new Error(\n                  `Incompatable @charset statements:\n  ${stmt.node.params} specified in ${stmt.node.source.input.file}\n  ${charset.node.params} specified in ${charset.node.source.input.file}`\n                )\n              }\n            }\n\n            // squash statements and their children\n            statements.forEach(stmt => {\n              if (stmt.type === \"charset\") handleCharset(stmt);\n              else if (stmt.type === \"import\") {\n                if (stmt.children) {\n                  stmt.children.forEach((child, index) => {\n                    if (child.type === \"import\") imports.push(child);\n                    else if (child.type === \"charset\") handleCharset(child);\n                    else bundle.push(child);\n                    // For better output\n                    if (index === 0) child.parent = stmt;\n                  });\n                } else imports.push(stmt);\n              } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n                bundle.push(stmt);\n              }\n            });\n\n            return charset\n              ? [charset, ...imports.concat(bundle)]\n              : imports.concat(bundle)\n          })\n      }\n\n      function resolveImportId(result, stmt, options, state) {\n        if (dataURL.isValid(stmt.uri)) {\n          return loadImportContent(result, stmt, stmt.uri, options, state).then(\n            result => {\n              stmt.children = result;\n            }\n          )\n        }\n\n        const atRule = stmt.node;\n        let sourceFile;\n        if (atRule.source?.input?.file) {\n          sourceFile = atRule.source.input.file;\n        }\n        const base = sourceFile\n          ? path.dirname(atRule.source.input.file)\n          : options.root;\n\n        return Promise.resolve(options.resolve(stmt.uri, base, options))\n          .then(paths => {\n            if (!Array.isArray(paths)) paths = [paths];\n            // Ensure that each path is absolute:\n            return Promise.all(\n              paths.map(file => {\n                return !path.isAbsolute(file)\n                  ? resolveId(file)\n                  : file\n              })\n            )\n          })\n          .then(resolved => {\n            // Add dependency messages:\n            resolved.forEach(file => {\n              result.messages.push({\n                type: \"dependency\",\n                plugin: \"postcss-import\",\n                file,\n                parent: sourceFile,\n              });\n            });\n\n            return Promise.all(\n              resolved.map(file => {\n                return loadImportContent(result, stmt, file, options, state)\n              })\n            )\n          })\n          .then(result => {\n            // Merge loaded statements\n            stmt.children = result.reduce((result, statements) => {\n              return statements ? result.concat(statements) : result\n            }, []);\n          })\n      }\n\n      function loadImportContent(result, stmt, filename, options, state) {\n        const atRule = stmt.node;\n        const { media, layer } = stmt;\n\n        assignLayerNames(layer, atRule, state, options);\n\n        if (options.skipDuplicates) {\n          // skip files already imported at the same scope\n          if (state.importedFiles[filename]?.[media]?.[layer]) {\n            return\n          }\n\n          // save imported files to skip them next time\n          if (!state.importedFiles[filename]) {\n            state.importedFiles[filename] = {};\n          }\n          if (!state.importedFiles[filename][media]) {\n            state.importedFiles[filename][media] = {};\n          }\n          state.importedFiles[filename][media][layer] = true;\n        }\n\n        return Promise.resolve(options.load(filename, options)).then(\n          content => {\n            if (content.trim() === \"\") {\n              result.warn(`${filename} is empty`, { node: atRule });\n              return\n            }\n\n            // skip previous imported files not containing @import rules\n            if (state.hashFiles[content]?.[media]?.[layer]) {\n              return\n            }\n\n            return processContent(\n              result,\n              content,\n              filename,\n              options,\n              postcss\n            ).then(importedResult => {\n              const styles = importedResult.root;\n              result.messages = result.messages.concat(importedResult.messages);\n\n              if (options.skipDuplicates) {\n                const hasImport = styles.some(child => {\n                  return child.type === \"atrule\" && child.name === \"import\"\n                });\n                if (!hasImport) {\n                  // save hash files to skip them next time\n                  if (!state.hashFiles[content]) {\n                    state.hashFiles[content] = {};\n                  }\n                  if (!state.hashFiles[content][media]) {\n                    state.hashFiles[content][media] = {};\n                  }\n                  state.hashFiles[content][media][layer] = true;\n                }\n              }\n\n              // recursion: import @import from imported file\n              return parseStyles(result, styles, options, state, media, layer)\n            })\n          }\n        )\n      }\n    },\n  }\n}\n\nAtImport.postcss = true;\n\nvar postcssImport = AtImport;\n\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postcssImport);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n  __proto__: null,\n  default: index\n}, [postcssImport]);\n\nexport { index$1 as i };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}