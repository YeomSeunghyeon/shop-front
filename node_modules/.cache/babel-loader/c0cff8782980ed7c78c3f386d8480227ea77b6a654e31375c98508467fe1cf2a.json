{"ast":null,"code":"/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"makeHangingPromise\", {\n  enumerable: true,\n  get: function () {\n    return makeHangingPromise;\n  }\n});\nfunction makeHangingPromise(signal, expression) {\n  const hangingPromise = new Promise((_, reject) => {\n    signal.addEventListener('abort', () => {\n      reject(new Error(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`unstable_after\\`, or similar functions you may observe this error and you should handle it in that context.`));\n    }, {\n      once: true\n    });\n  });\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject);\n  return hangingPromise;\n}\nfunction ignoreReject() {}","map":{"version":3,"names":["makeHangingPromise","signal","expression","hangingPromise","Promise","_","reject","addEventListener","Error","once","catch","ignoreReject"],"sources":["C:\\Users\\100li\\node_modules\\next\\src\\server\\dynamic-rendering-utils.ts"],"sourcesContent":["/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  const hangingPromise = new Promise<T>((_, reject) => {\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(\n          new Error(\n            `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`unstable_after\\`, or similar functions you may observe this error and you should handle it in that context.`\n          )\n        )\n      },\n      { once: true }\n    )\n  })\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject)\n  return hangingPromise\n}\n\nfunction ignoreReject() {}\n"],"mappings":"AAAA;;;;;;GAMC;;;;;+BACe;;;WAAAA,kBAAA;;;AAAT,SAASA,mBACdC,MAAmB,EACnBC,UAAkB;EAElB,MAAMC,cAAA,GAAiB,IAAIC,OAAA,CAAW,CAACC,CAAA,EAAGC,MAAA;IACxCL,MAAA,CAAOM,gBAAgB,CACrB,SACA;MACED,MAAA,CACE,IAAIE,KAAA,CACF,wBAAwBN,UAAA,wGAAkHA,UAAA,gKAA0K;IAG1T,GACA;MAAEO,IAAA,EAAM;IAAK;EAEjB;EACA;EACA;EACA;EACAN,cAAA,CAAeO,KAAK,CAACC,YAAA;EACrB,OAAOR,cAAA;AACT;AAEA,SAASQ,aAAA,GAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}